"""
This is a small python program for generating force displacement relations 
between two spheres of dissimilar size and material

The code is based on the paper "A Unified Model for the Contact Behaviour 
between Equal and Dissimilar Elastic-Plastic Spherical Bodies" by Erik Olsson
and Per-Lennart Larsson. Questions and comments regarding the code (and the 
paper) are very welcomed to erolsson@kth.se

The code requires python 2.7 to run as well as the free libraries numpy, scipy 
and matplotlib (for the plotting). A free package for Windows users, 
including all the rquirements, can be found at:
https://store.continuum.io/cshop/anaconda/

------------------------------------------------------------------------------
Usage of code:

Firstly, the two spheres involved in the analyis must be defined which is 
done by
s1 = Spehre(R1, mat1)
s2 = Spehre(R2, mat2)
where R1 and R2 are the radii of the spheres and mat1 and mat2 are vectors with
3 to 5 elements with material parameters

Example of material vectors:
mat = [E,v,sY] creates an ideal-plastic material with Young's modulus E, 
               Possions ratio, v, and yield stress sY

mat = [E,v,s0,m] creates a strain hardnening material with two parameters 
                 (Eq. 6) 

mat = [E,v,sY,k,m] creates a strain hardnening material with three parameters 
                   (Eq. 8) 

The contact data is generated by the function
h,F,a,R = generateContactData(sphere1,sphere2,hMax,dF, largeDef)
with the parameters:
spehre1, sphere2  The created spheres
hMax               the maximum desired indentation depth 
                   [standard units, mm if stresses are in MPa and radii in mm]
dF                 increment of force for each iteration [standard units]
largeDef           boolean (True or False) if the large deformation model for
                   the hardness should be activated

and return values
h    numpy array with the computed indentation depths
a    numpy array with the computed contact radius
F    numpy array with the contact force, elements spaced with dF
R    numpy array with the computed radius of the assumed spherical contact 
     surface

There are a few parameters that are set prior to the analysis
fitToFunction  True or False. If the contact data should be fitted to the 
               functions in the appendix, Eq A.1 and Eq. A2

writeToFile    True or False. If the results should be written to a comma 
               separated file with columns h,F,a,R

fileName       String. Filename of the output file, has only effect if 
               writeToFile = True
**UPDATED FUNCTIONALITY********************************************************

fitFileName     String. Filename for the fitted and normalized contact
                coefficients. Written to a .dat file with rows F_1, alpha_1,F_2,
                 alpha_2, a_1, beta_1, a_2, beta_2, with F and a normalized

"""

#==============================================================================
#               *** *** *** *** Example code *** *** *** ***
#=============================================================================

#importing necessary libraries
import numpy as np                     #numpy
import matplotlib.pyplot as plt        #plotting functions
from scipy.optimize import fmin        #minimizing function for fitting
from elasticPlasticContact import *    #The contact engine

plt.style.use('axel_style')

#parameters prior to the analysis
fitToFunction = True
writeToFile = False
fileName = "contactData.dat"
fitFileName= 'contact_fit_coefficients.dat'

#Creating 2 spheres of radii 0.02 mm and 0.03 mm respectively with strain
#hardening material with parameters E=910 MPa, v = 0.3, sY = 1 MPa, kappa=10
#and m=2 (Material C in the paper)

# Input length in mm and stress in MPa
R1 = 1000
E1 = 140e3
nu1 = 0.3
sY1 = 3.3e3
kappa1 = 1
m1 = 1

R2 = 1000
E2 = 140e3
nu2 = 0.3
sY2 = 3.3e3
kappa2 = 1
m2 = 1


# R1 = 1000
# E1 = 140e3
# nu1 = 0.3
# sY1 = 4e3
# kappa1 = 1
# m1 = 1
#
# R2 = 1000
# E2 = 140e3
# nu2 = 0.3
# sY2 = 4e3
# kappa2 = 1
# m2 = 1

# R1 = 12
# E1 = 140e9
# nu1 = 0.3
# sY1 = 4e9
# kappa1 = 1
# m1 = 1
#
# R2 = 4
# E2 = 140e9
# nu2 = 0.3
# sY2 = 4e9
# kappa2 = 1
# m2 = 1





s1 = Sphere(R1, [E1, nu1, sY1])
s2 = Sphere(R2, [E2, nu2, sY2])

#Defining the effective radius accordning to Eq. (31)
R0 = 1./(1./R1 + 1./R2)

# Maximum indentation depths 20% of R0
hMax = 0.25*R0

#the increase in force for each iteration
#Assuming that the force at hMax will be 10 * R0^2 * sY
#this will results in 100 steps
dF = 1*R0**2*sY1/100

#Generating the contact data
h,F,a,R = generateContactData(s1,s2,hMax,dF, largeDef=True)
plt.figure(0)

#Plotting the results
plt.plot(h, F, 'b', lw=2, label = 'Model')

plt.figure(1)
plt.plot(h,a, 'b',  lw=2, label = 'Model')

plt.figure(2)
plt.plot(h/R0, F/(R0**2 * sY1), 'b', lw=2, label = 'Model')


plt.figure(3)
plt.plot(h/R0, a/R0, 'b',  lw=2, label = 'Model')

if fitToFunction:
    plt.figure(0)
    data = F,h
    par_F = fmin(baseFuncOpt, [1,1,1,1], args=data, ftol=1E-12, disp=False,
               maxfun=1E6,maxiter=1E6)
    print(par_F)


    print()
    print( "The F(h) relationship is fitted to Eq. (A.1) with parameters")
    print( "F1 =",par_F[0],"a1 =", par_F[1],"F2 =",par_F[2],"a2 =", par_F[3])
    print()
    plt.plot(h, baseFunc(h,par_F), '--b', lw=2, label = 'Eq. (A.1)')

    plt.figure(2)
    plt.plot(h / R0, baseFunc(h,par_F) / (R0 ** 2 * sY1), '--b', lw=2, label='Eq. (A.1)')

    par_F[0] = par_F[0] / (R0 ** (2 - par_F[1]) * sY1)
    par_F[2] = par_F[2] / (R0 ** (2 - par_F[3]) * sY1)

    print()
    print("The normalised F(h) relationship is fitted to Eq. (A.1) with parameters")
    print("F1 =", par_F[0], "a1 =", par_F[1], "F2 =", par_F[2], "a2 =", par_F[3])
    print()

    plt.figure(1)
    data = a,h
    par_a = fmin(baseFuncOpt, [1,1,1,1], args=data, ftol=1E-12, disp=False,
               maxfun=1E6,maxiter=1E6)

    print( "The a(h) relationship is fitted to Eq. (A.2) with parameters")
    print( "a1 =",par_a[0],"b1 =", par_a[1],"a2 =",par_a[2],"b2 =", par_a[3])
    plt.plot(h, baseFunc(h,par_a), '--b', lw=2, label = 'Eq. (A.2)')

    plt.figure(3)
    plt.plot(h/R0, baseFunc(h,par_a)/R0, '--b', lw=2, label = 'Eq. (A.2)')



    # par_a[0:1] = par_a[0:1] / (R0**(1++par_a[2:3]))
    par_a[0] = par_a[0] / (R0 ** (1 - par_a[1]))
    par_a[2] = par_a[2] / (R0 ** (1 - par_a[3]))


if writeToFile:
    np.savetxt(fileName, np.vstack([h,F,a,R]).T, delimiter=",")
    #======================================================================
    # np.savetxt(fitFileName,np.hstack((((R0*1e-3)**2 * sY1*1e6) ** (-par_F[1]) * 10**(3*par_F[1]) * par_F[0]/((R0*1e-3)**2 * sY1*1e6),par_F[1], ((R0*1e-3)**2 * sY1*1e6) ** (-par_F[3]) * 10**(3*par_F[3]) * par_F[2]/((R0*1e-3)**2 * sY1*1e6),par_F[3],(R0*1e-3) ** (-par_a[1]) * 10**(3*par_a[1]) * par_a[0]/(R0*1e-3),par_a[1], (R0*1e-3) ** (-par_a[3]) * 10**(3*par_a[3]) * par_a[2] /(R0*1e-3),par_a[3])), delimiter=',')
    np.savetxt(fitFileName, np.hstack((par_F,par_a)), delimiter=',')
    # some scaling wrong here!!============================================



plt.figure(0)
plt.xlabel('$h$ [mm]')
plt.ylabel('$F$ [N]')
plt.legend(loc='best')

plt.figure(1)
plt.xlabel('$h$ [mm]')
plt.ylabel('$a$ [mm]')
plt.legend(loc='best')

plt.figure(2)
plt.xlabel('$h/R_0$ [mm/mm]')
plt.ylabel('$F/R_0^2 \sigma_Y$ [MPa/MPa]')
plt.legend(loc='best')


plt.figure(3)
plt.xlabel('$h/R_0$ [mm/mm]')
plt.ylabel('$a/R_0$ [mm/mm]')
plt.legend(loc='best')

plt.show()
